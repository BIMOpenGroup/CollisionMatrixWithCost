## Ключевая идея
- Единица расчёта — ровно одна ячейка пересечения строки и колонки.
- Везде явно указываем, какая `строка × колонка` рассчитывается (группа/метка обеих осей).
- Для каждой ячейки поддерживаем несколько видов работ с ранжированием и выбором пользователем.

## Схема данных (новые сущности)
1) `cell_keys`
- Поля: `row_index`, `col_index`, `row_group`, `row_label`, `col_group`, `col_label` (уникальный ключ пары `row_index+col_index`).
- Хранит стабильные ключи ячеек матрицы, чтобы привязка не ломалась при обновлении CSV.

2) `cell_suggestions`
- Поля: `cell_id`, `work_type`, `price_id`, `score`, `method` (heuristic+llm), `status` (`proposed|accepted|rejected`), `created_at`.
- Это варианты расчёта для ячейки с ранжированием.

3) `cell_items` (принятые расчёты)
- Поля: `cell_id`, `work_type`, `price_id`, `quantity`, `unit_price`, `currency`, `total`, `source`, `source_page`, `created_at`.
- Можно хранить несколько записей на одну ячейку (несколько видов работ или несколько позиций).

4) `suggestion_events` (уже есть — используем для аудита)
- Добавим поддержку типа `cell` и привязку к `cell_id`.

## Алгоритм расчёта (одна ячейка)
- Вход: `(row_index, col_index)` → получаем `row_group/row_label`, `col_group/col_label`.
- Кандидаты: цены из `prices`, скоринг по объединённым токенам:
  - Токены из `row_group/row_label` и `col_group/col_label`.
  - Мягкие бусты по совпадениям категорий.
- Классификация `work_type` (вид работ):
  - Выводим топ‑N кандидатов сгруппированных по work_type (эвристика по словарям ключевых слов; опционально LLM‑классификация).
- LLM‑rerank (единый провайдер из `LLM_*` env):
  - Промпт содержит явное указание на `строка × колонка` и список кандидатов.
- Сохраняем `cell_suggestions` со статусом `proposed`.

## API (новые эндпоинты)
- `POST /api/cells/init` → синхронизирует `cell_keys` с текущей матрицей (индексы, группы, метки).
- `POST /api/cells/:rowIndex/:colIndex/suggest` → строит предложения (`cell_suggestions`) для одной ячейки.
- `GET /api/cells/:rowIndex/:colIndex/suggestions?work_type=...&limit=...` → список предложений по ячейке.
- `POST /api/cells/suggestions/:id/status` body `{status}` → принять/отклонить предложение; аудит (`type:'cell'`).
- `POST /api/cells/:rowIndex/:colIndex/items` → добавить принятый элемент с количеством, ценой и источником; рассчитываем `total`.
- `GET /api/cells/:rowIndex/:colIndex/items` → читать принятые элементы (для отображения в клетке и карточке).
- Все LLM‑вызовы через единые `LLM_*` (без провайдер‑ветвлений).

## UI (новая вкладка «Матрица со стоимостью»)
- Вкладка повторяет сетку матрицы, но:
  - Клик по ячейке открывает карточку «Расчёт: `row_group / row_label × col_group / col_label`».
  - Кнопка «Сгенерировать предложения (ячейка)» вызывает расчет для конкретной ячейки.
  - Выпадающий список `work_type`: фильтр по видам работ; таблица предложений (`name/unit/category/score/source`), действия «Принять/Отклонить».
  - Блок «Принятые позиции ячейки»: список выбранных работ с `quantity`, `unit_price`, `total`, источник.
  - В самой ячейке отображается уже расчитанная стоймость, или же диапазон стоймостей если пользователь одобрил несколько вариантов расчёта.
- Везде явно показываем `row × col` идентификаторы и метки.

## Единый источник правды для LLM
- Убираем из UI/Backend провайдеры и ветвления; используем только `LLM_BASE_URL`, `LLM_API_KEY`, `LLM_MODEL`.
- Эндпоинт пинга/проверки отражает только `llm` (единый) и статусы из `LLM_*`.

## Виды работ (work_type)
- Эвристические словари (расширяемые) + опциональная LLM‑классификация для распределения кандидатов по типам.
- Пользователь может сменить `work_type` фильтр и выбрать несколько позиций.

## Верификация
- Синхронизация `cell_keys` с матрицей; smoke‑тест расчёта одной ячейки; принятие нескольких позиций; аудит.
- Вкладка «Журнал» уже показывает события — добавим тип `cell`.

## Этапы внедрения
1) База: таблицы `cell_keys`, `cell_suggestions`, `cell_items`; расширение `suggestion_events`.
2) API: init/suggest/list/status/items для ячейки; единый `LLM_*`.
3) UI: новая вкладка «Матрица со стоимостью», карточка ячейки, фильтры и принятие.
4) Полировка: агрегаты в ячейке (`Σ total`), сортировка, пагинация.

## Ограничения и безопасность
- Не храним/не выводим ключи; источники цен показываем как есть (без изменения ссылок).
- Расчёт всегда строго для одной ячейки; массовые операции только через последовательные вызовы per‑cell.